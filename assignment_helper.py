{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "RuntimeError",
     "evalue": "No quantum computing framework available!",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-1-0d6905b84166>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m    155\u001b[0m         \u001b[0mis_dwave\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    156\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mis_qiskit\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mis_forest\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 157\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"No quantum computing framework available!\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    158\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mis_dwave\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    159\u001b[0m         \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"D-Wave Ocean is not available!\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mRuntimeError\u001b[0m: No quantum computing framework available!"
     ]
    }
   ],
   "source": [
    "import itertools\n",
    "import numpy as np\n",
    "import scipy\n",
    "import socket\n",
    "import subprocess\n",
    "import time\n",
    "\n",
    "\n",
    "def get_free_port():\n",
    "    sock = socket.socket()\n",
    "    sock.bind(('', 0))\n",
    "    port = sock.getsockname()[1]\n",
    "    sock.close()\n",
    "    return port\n",
    "\n",
    "\n",
    "def init_qvm_and_quilc(qvm_executable=\"qvm\", quilc_executable=\"quilc\"):\n",
    "    qvm_port = get_free_port()\n",
    "    quilc_port = get_free_port()\n",
    "    qvm_server = subprocess.Popen([qvm_executable, \"-S\", \"-p\", str(qvm_port)])\n",
    "    quilc_server = subprocess.Popen([quilc_executable, \"-R\", \"-p\", str(quilc_port)])\n",
    "    fc = ForestConnection(sync_endpoint='http://127.0.0.1:' + str(qvm_port),\n",
    "                          compiler_endpoint='tcp://127.0.0.1:' + str(quilc_port))\n",
    "    time.sleep(5)\n",
    "    return qvm_server, quilc_server, fc\n",
    "\n",
    "\n",
    "def get_amplitudes(circuit):\n",
    "    if isinstance(circuit, qiskit.circuit.quantumcircuit.QuantumCircuit):\n",
    "        backend = Aer.get_backend('statevector_simulator')\n",
    "        job = execute(circuit, backend)\n",
    "        amplitudes = job.result().get_statevector(circuit)\n",
    "    elif isinstance(circuit, pyquil.quil.Program):\n",
    "        wf_sim = WavefunctionSimulator(connection=fc)\n",
    "        wavefunction = wf_sim.wavefunction(circuit)\n",
    "        amplitudes = wavefunction.amplitudes\n",
    "    else:\n",
    "        raise ValueError(\"Unknown circuit type\")\n",
    "    return amplitudes\n",
    "\n",
    "\n",
    "def get_counts(circuit, num_shots=100):\n",
    "    if isinstance(circuit, qiskit.circuit.quantumcircuit.QuantumCircuit):\n",
    "        backend = Aer.get_backend('qasm_simulator')\n",
    "        job = execute(circuit, backend, shots=num_shots)\n",
    "        result = job.result()\n",
    "        counts = result.get_counts(circuit)\n",
    "    elif isinstance(circuit, pyquil.quil.Program):\n",
    "        n_qubits = len(circuit.get_qubits())\n",
    "        circuit.wrap_in_numshots_loop(num_shots)\n",
    "        qc = get_qc(str(n_qubits) + 'q-qvm', connection=fc)\n",
    "        executable = qc.compile(circuit)\n",
    "        result = qc.run(executable)\n",
    "        classical_bits = get_classical_bits(circuit)\n",
    "        counts = {}\n",
    "        for bitstring in itertools.product(*[{1, 0} for _ in range(classical_bits)]):\n",
    "            key = \"\".join(str(i) for i in bitstring)\n",
    "            value = sum([tuple(d.tolist()) == bitstring for d in result])\n",
    "            counts[key] = value\n",
    "    else:\n",
    "        raise ValueError(\"Unknown circuit type\")\n",
    "    return counts\n",
    "\n",
    "\n",
    "def get_single_measurement_counts(circuit, num_shots=100):\n",
    "    if isinstance(circuit, qiskit.circuit.quantumcircuit.QuantumCircuit):\n",
    "        backend = Aer.get_backend('qasm_simulator')\n",
    "        job = execute(circuit, backend, shots=num_shots)\n",
    "        result = job.result()\n",
    "        counts = result.get_counts(circuit)\n",
    "    elif isinstance(circuit, pyquil.quil.Program):\n",
    "        n_qubits = len(circuit.get_qubits())\n",
    "        circuit.wrap_in_numshots_loop(num_shots)\n",
    "        qc = get_qc(str(n_qubits) + 'q-qvm', connection=fc)\n",
    "        executable = qc.compile(circuit)\n",
    "        result = qc.run(executable)\n",
    "        classical_bits = get_classical_bits(circuit)\n",
    "        counts = {}\n",
    "        for bitstring in itertools.product(*[{1, 0} for _ in range(classical_bits)]):\n",
    "            key = \"\".join(str(i) for i in bitstring)\n",
    "            counts[key] = 0\n",
    "        counts[\"0\" * classical_bits] = (result == 0).sum()\n",
    "        counts[\"0\" * (classical_bits-1) + \"1\"] = (result == 1).sum()\n",
    "    else:\n",
    "        raise ValueError(\"Unknown circuit type\")\n",
    "    return counts\n",
    "\n",
    "\n",
    "def get_classical_bits(circuit):\n",
    "    if isinstance(circuit, qiskit.circuit.quantumcircuit.QuantumCircuit):\n",
    "        classical_bits = circuit.cregs[0].size\n",
    "    elif isinstance(circuit, pyquil.quil.Program):\n",
    "        for instruction in circuit.instructions:\n",
    "            if isinstance(instruction, pyquil.quilbase.Declare):\n",
    "                classical_bits = instruction.memory_size\n",
    "                break\n",
    "    else:\n",
    "        raise ValueError(\"Unknown circuit type\")\n",
    "    return classical_bits\n",
    "\n",
    "\n",
    "def get_circuit_length(circuit):\n",
    "    if isinstance(circuit, qiskit.circuit.quantumcircuit.QuantumCircuit):\n",
    "        program_length = sum(circuit.count_ops().values())\n",
    "    elif isinstance(circuit, pyquil.quil.Program):\n",
    "        program_length = len(circuit.instructions)\n",
    "    else:\n",
    "        raise ValueError(\"Unknown circuit type\")\n",
    "    return program_length\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    try:\n",
    "        import grove\n",
    "        import pyquil\n",
    "        from grove.pyvqe import vqe\n",
    "        from pyquil import Program, get_qc\n",
    "        from pyquil.paulis import PauliSum, PauliTerm, exponential_map, sZ\n",
    "        from pyquil.api import WavefunctionSimulator, ForestConnection\n",
    "        from pyquil.gates import *\n",
    "        try:\n",
    "            qvm_server, quilc_server, fc = init_qvm_and_quilc()\n",
    "            is_forest = True\n",
    "        except FileNotFoundError:\n",
    "            try:\n",
    "                prefix = \"/home/local/bin/\"\n",
    "                qvm_server, quilc_server, fc = init_qvm_and_quilc(prefix+\"qvm\",\n",
    "                                                                  prefix + \"quilc\")\n",
    "                is_forest = True\n",
    "            except FileNotFoundError:\n",
    "                is_forest = False\n",
    "    except ImportError:\n",
    "        is_forest = False\n",
    "    try:\n",
    "        import qiskit\n",
    "        import qiskit.aqua\n",
    "        from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n",
    "        from qiskit import execute\n",
    "        try:\n",
    "            from qiskit import Aer\n",
    "        except ImportError:\n",
    "            from qiskit import BasicAer as Aer\n",
    "        from qiskit.quantum_info import Pauli\n",
    "        from qiskit.aqua import Operator, get_aer_backend\n",
    "        from qiskit.aqua.components.initial_states import Custom\n",
    "        is_qiskit = True\n",
    "    except ImportError:\n",
    "        is_qiskit = False\n",
    "    try:\n",
    "        import dimod\n",
    "        import dwave_networkx\n",
    "        import minorminer\n",
    "        is_dwave = True\n",
    "    except ImportError:\n",
    "        is_dwave = False\n",
    "    if not (is_qiskit or is_forest):\n",
    "        raise RuntimeError(\"No quantum computing framework available!\")\n",
    "    if not is_dwave:\n",
    "        raise RuntimeError(\"D-Wave Ocean is not available!\")\n",
    "    print(\"Available frameworks:\")\n",
    "    if is_forest:\n",
    "        print(\"Forest SDK\")\n",
    "    if is_qiskit:\n",
    "        print(\"Qiskit\")\n",
    "    if is_dwave:\n",
    "        print(\"D-Wave Ocean\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
